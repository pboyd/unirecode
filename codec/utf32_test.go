package codec

import (
	"bytes"
	"testing"
)

func TestUTF32Decoder(t *testing.T) {
	cases := []struct {
		decoder  Decoder
		in       []byte
		expected string
	}{
		{
			decoder: NewUTF32LEDecoder(),
			in: []byte{
				0x44, 0x00, 0x00, 0x00,
				0x6f, 0x00, 0x00, 0x00,
				0x77, 0x00, 0x00, 0x00,
				0x6e, 0x00, 0x00, 0x00,
			},
			expected: "Down",
		},
		{
			decoder: NewUTF32BEDecoder(),
			in: []byte{
				0x00, 0x00, 0x00, 0x74,
				0x00, 0x00, 0x00, 0x68,
				0x00, 0x00, 0x00, 0x65,
			},
			expected: "the",
		},
		{
			decoder: NewUTF32Decoder(),
			in: []byte{
				0x52, 0x00, 0x00, 0x00,
				0x61, 0x00, 0x00, 0x00,
				0x62, 0x00, 0x00, 0x00,
				0x62, 0x00, 0x00, 0x00,
				0x69, 0x00, 0x00, 0x00,
				0x74, 0x00, 0x00, 0x00,
			},
			expected: "Rabbit",
		},
		{
			decoder: NewUTF32Decoder(),
			in: []byte{
				0xff, 0xfe, 0x00, 0x00,
				0x48, 0x00, 0x00, 0x00,
				0x6F, 0x00, 0x00, 0x00,
				0x6C, 0x00, 0x00, 0x00,
				0x65, 0x00, 0x00, 0x00,
			},
			expected: "Hole",
		},
		{
			decoder: NewUTF32LEDecoder(),
			in: []byte{
				0x20, 0x22, 0x00, 0x00,
				0x09, 0x06, 0x00, 0x00,
				0xA1, 0x20, 0x00, 0x00,
				0x0E, 0xF3, 0x01, 0x0,
			},
			expected: "âˆ Ø‰â‚¡ðŸŒŽ",
		},
		{
			decoder: NewUTF32BEDecoder(),
			in: []byte{
				0x00, 0x00, 0x22, 0x20,
				0x00, 0x00, 0x06, 0x09,
				0x00, 0x00, 0x20, 0xA1,
				0x00, 0x01, 0xF3, 0x0E,
			},
			expected: "âˆ Ø‰â‚¡ðŸŒŽ",
		},
		{
			decoder: NewUTF32Decoder(),
			in: []byte{
				0x20, 0x22, 0x00, 0x00,
				0x09, 0x06, 0x00, 0x00,
				0xA1, 0x20, 0x00, 0x00,
				0x0E, 0xF3, 0x01, 0x0,
			},
			expected: "âˆ Ø‰â‚¡ðŸŒŽ",
		},
		{
			decoder: NewUTF32Decoder(),
			in: []byte{
				0x00, 0x00, 0x22, 0x20,
				0x00, 0x00, 0x06, 0x09,
				0x00, 0x00, 0x20, 0xA1,
				0x00, 0x01, 0xF3, 0x0E,
			},
			expected: "âˆ Ø‰â‚¡ðŸŒŽ",
		},
	}

	encoder := NewUTF8Encoder()

	for _, c := range cases {
		actual := &bytes.Buffer{}

		err := Recode(bytes.NewReader(c.in), actual, c.decoder, encoder)
		if err != nil {
			t.Errorf("recode error: %v", err)
			continue
		}

		if actual.String() != c.expected {
			t.Errorf("got %q, want %q", actual.String(), c.expected)
		}
	}
}

func TestUTF32Encoder(t *testing.T) {
	cases := []struct {
		encoder  Encoder
		in       string
		expected []byte
	}{
		{
			encoder: NewUTF32LEEncoder(),
			in:      "Down",
			expected: []byte{
				0x44, 0x00, 0x00, 0x00,
				0x6f, 0x00, 0x00, 0x00,
				0x77, 0x00, 0x00, 0x00,
				0x6e, 0x00, 0x00, 0x00,
			},
		},
		{
			encoder: NewUTF32BEEncoder(),
			in:      "the",
			expected: []byte{
				0x00, 0x00, 0x00, 0x74,
				0x00, 0x00, 0x00, 0x68,
				0x00, 0x00, 0x00, 0x65,
			},
		},
		{
			encoder: NewUTF32LEEncoder(),
			in:      "Rabbit",
			expected: []byte{
				0x52, 0x00, 0x00, 0x00,
				0x61, 0x00, 0x00, 0x00,
				0x62, 0x00, 0x00, 0x00,
				0x62, 0x00, 0x00, 0x00,
				0x69, 0x00, 0x00, 0x00,
				0x74, 0x00, 0x00, 0x00,
			},
		},
		{
			encoder: NewUTF32BEEncoder(),
			in:      "Hole",
			expected: []byte{
				0x00, 0x00, 0x00, 0x48,
				0x00, 0x00, 0x00, 0x6F,
				0x00, 0x00, 0x00, 0x6C,
				0x00, 0x00, 0x00, 0x65,
			},
		},
		{
			encoder: NewUTF32LEEncoder(),
			in:      "âˆ Ø‰â‚¡ðŸŒŽ",
			expected: []byte{
				0x20, 0x22, 0x00, 0x00,
				0x09, 0x06, 0x00, 0x00,
				0xA1, 0x20, 0x00, 0x00,
				0x0E, 0xF3, 0x01, 0x0,
			},
		},
		{
			encoder: NewUTF32BEEncoder(),
			in:      "âˆ Ø‰â‚¡ðŸŒŽ",
			expected: []byte{
				0x00, 0x00, 0x22, 0x20,
				0x00, 0x00, 0x06, 0x09,
				0x00, 0x00, 0x20, 0xA1,
				0x00, 0x01, 0xF3, 0x0E,
			},
		},
	}

	decoder := NewUTF8Decoder()

	for _, c := range cases {
		actual := &bytes.Buffer{}

		err := Recode(bytes.NewReader([]byte(c.in)), actual, decoder, c.encoder)
		if err != nil {
			t.Errorf("recode error: %v", err)
			continue
		}

		if !bytes.Equal(actual.Bytes(), c.expected) {
			t.Errorf("got %v, want %v", actual.Bytes(), c.expected)
		}
	}
}
